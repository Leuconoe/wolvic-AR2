# METALENSE2 Compositor Layer Fix - Session 7 Walkthrough

## Summary

**Root cause found and fixed**: The Snapdragon Spaces compositor could not efficiently composite 6 OpenXR layers at resolutions above 50%. Disabling compositor layers (rendering all UI into the single projection layer) achieved **90 FPS at full resolution**.

## Problem Statement

After fixing swapchain sampleCount (Session 6), the app ran at 90 FPS at 50% resolution but showed catastrophic performance at 55%+:

| Scale | Resolution/eye | FPS | Frame Delta |
|-------|---------------|-----|-------------|
| 0.50 | 1280×720      | 90  | 9-13ms      |
| 0.55 | 1408×792      | 2-4 | 105-2013ms  |
| 0.65 | 1664×935      | 0   | 2013ms      |
| 0.75 | 1920×1080     | 0.5 | 2019ms      |

A 21% increase in pixels (50%→55%) caused a 200x performance drop — clearly not a linear GPU fill-rate issue.

## Root Cause Analysis

### Step 1: xrEndFrame is NOT the compositor bottleneck

Added timing around `xrEndFrame()` in the `submitEndFrame` lambda:

```
EndFrame#261 delta=2010ms xrEnd=2ms layers=6
EndFrame#266 delta=2013ms xrEnd=3ms layers=6
```

**xrEndFrame takes only 1-3ms**, not 2 seconds. The stall is elsewhere.

### Step 2: xrWaitFrame and xrBeginFrame are fast

Added timing to StartFrame around `xrWaitFrame` and `xrBeginFrame`:

```
SF#250 wait=2ms begin=0ms render=1 sess=5
```

Both complete in <10ms. The OpenXR frame synchronization is NOT the bottleneck.

### Step 3: The stall is in eye rendering — specifically xrWaitSwapchainImage

Added per-phase timing in `BrowserWorld::Draw()`:

```
Draw#235 total=2015ms sf=9ms left=1000ms right=1002ms ef=2ms
```

**Each eye takes EXACTLY 1000ms!** This is a blocking synchronization, not GPU rendering.

The call chain is:
1. `BrowserWorld::Draw(Eye::Left)` → `DrawWorld(Eye::Left)` → `m.device->BindEye(Left)`
2. `BindEye()` → `m.boundSwapChain->AcquireImage()`
3. `AcquireImage()` → `xrWaitSwapchainImage(swapchain, &waitInfo)` with `waitInfo.timeout = XR_INFINITE_DURATION`

`xrWaitSwapchainImage` blocks until the compositor releases the swapchain image. When the compositor is overloaded with 6 layers at higher resolution, it holds images longer, causing 1-second blocking waits per eye.

### Step 4: The compositor layer count is the trigger

The app submitted **6 composition layers** per frame:
- Passthrough/skybox layer (conditional)
- Back UI quad layers (browser windows as AndroidSurface swapchains)
- Projection layer (eye buffer — 2 views)
- Front UI quad layers (overlays)

At 50% resolution, the compositor could handle 6 layers within the frame budget. At 55%+, the total pixel throughput exceeded the GPU's capacity at 305 MHz, causing image availability starvation.

## The Fix

### Disable compositor layers for SPACES builds

In `DeviceDelegateOpenXR.cpp`, after the `layersEnabled` assignment:

```cpp
layersEnabled = systemProperties.graphicsProperties.maxLayerCount > 1 
    && OpenXRExtensions::IsExtensionSupported(XR_KHR_ANDROID_SURFACE_SWAPCHAIN_EXTENSION_NAME);
#if SPACES
// Disable compositor layers on Spaces to reduce compositor overhead.
// All UI is rendered into the projection layer instead.
layersEnabled = false;
#endif
```

When `layersEnabled = false`:
- `CreateLayerQuad()` returns nullptr
- Widget system falls back to SurfaceTexture-based rendering
- GeckoView content renders to SurfaceTexture → GL texture → drawn as quad in scene graph
- Only **1 composition layer** (projection) submitted to compositor
- Compositor overhead drops from 6× to 1×

### Results after fix

| Scale | Resolution/eye | FPS  | Frame Delta | Layers |
|-------|---------------|------|-------------|--------|
| 0.65  | 1664×935      | 90   | 9-13ms      | 1      |
| 0.75  | 1920×1080     | 90   | 9-14ms      | 1      |
| 1.00  | 2560×1440     | 90   | 7-14ms      | 1      |

**Full resolution, 90 FPS, even at minimum GPU frequency (305 MHz).**

### Resolution scale set to 1.0

Since layers disabled eliminates the compositor bottleneck:
- `kMetalense2ResolutionScale = 1.0f` (full native resolution)
- The constant is kept for future tuning if needed

## All Diagnostic Code Removed

The following temporary instrumentation was added during debugging and removed for the final build:

### DeviceDelegateOpenXR.cpp
- `#include <chrono>` (added for timing)
- StartFrame: `sFrameCount`, `VRB_LOG("SPACES_PERF: StartFrame ENTER...")`, timing around xrWaitFrame/xrBeginFrame
- EndFrame lambda: `endFrameCount`, `beforeEndFrame`, timing around xrEndFrame, delta logging
- `shouldRender=false DIAG` block

### native-lib.cpp
- `VRB_LOG("MaybeInitGLAndEnterVR: ...")` logging
- `DIAG: Draw skipped` else branch with skipCount

### BrowserWorld.h / BrowserWorld.cpp
- `Draw()` moved from inline to cpp with per-phase timing
- Reverted to original inline definition

## Complete Fix Summary (All Sessions)

### Files Modified

1. **DeviceDelegateOpenXR.cpp** — Performance fixes:
   - `layersEnabled = false` for `#if SPACES` (compositor layer fix — THIS SESSION)
   - `info.sampleCount = 1` for `#if SPACES` (swapchain fix — Session 6)
   - `attributes.samples = 0` for `#if SPACES` (FBO MSAA disable — Session 5)
   - SUSTAINED_HIGH CPU+GPU perf settings (Session 5)
   - `kMetalense2ResolutionScale = 1.0f` (now full resolution — this session)
   - Resolution scaling code for Metalense2 in GetSwapChainCreateInfo/InitializeImmersiveDisplay (Session 5)

2. **Device.h** — `Metalense2 = 24` (Session 1)
3. **DeviceType.java** — Device type enum (Session 1)
4. **DeviceUtils.cpp** — Device detection (Session 1)
5. **OpenXRInputSource.cpp** — Force hand tracking for SPACES (Session 2)
6. **OpenXRExtensions.cpp** — Hand interaction extension erasure for SPACES (Session 3)
7. **SettingsStore.java** — Metalense2 removed from passthrough default (Session 3)
8. **ExternalVR.cpp** — LenovoA3/Metalense2 → OculusGo controller type (Session 3)

## Key Learnings

1. **Compositor layer count matters more than resolution** on constrained GPUs. 6 layers with AndroidSurface swapchains creates massive IPC and GPU composition overhead.

2. **xrWaitSwapchainImage with XR_INFINITE_DURATION** can block for seconds when the compositor is overloaded. This is the mechanism that converts compositor slowness into app frame drops.

3. **The stall pattern was exactly 1000ms per eye** — suggesting an internal timeout or cycle in the Monado/Spaces compositor when it can't keep up.

4. **GPU frequency management** in the Spaces runtime is broken — SUSTAINED_HIGH perf hints are not honored. The GPU stays at 305 MHz minimum despite the request. However, with layers disabled, even 305 MHz is sufficient for 90 FPS.

5. **Resolution was a red herring** — the real bottleneck was compositor layer compositing, not eye buffer fill rate. Full resolution (2560×1440/eye) runs fine with 1 layer.
