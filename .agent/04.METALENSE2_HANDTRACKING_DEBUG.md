# METALENSE2 Hand Tracking Performance Debug - Urgent Fix Required

## Context

The app is now running on METALENSE2, but **hand tracking updates extremely slowly**, causing laggy and unresponsive hand movements. The overall app performance is also slow. These issues need to be debugged and fixed.

**Continue working autonomously until I explicitly tell you to stop.**

---

## Current Status

- ✅ Build successful
- ✅ App runs on METALENSE2
- ✅ Hand tracking is detected and works
- ❌ **Hand tracking updates very slowly** (lag/jitter visible)
- ❌ **Overall app performance is slow**

---

## Available Debugging Tools

### 1. Built-in Logging System (`vrb/Logger.h`)

```cpp
#include "vrb/Logger.h"

VRB_DEBUG(format, ...)  // Debug log (disabled in Release builds)
VRB_LOG(format, ...)    // Info log
VRB_WARN(format, ...)   // Warning log
VRB_ERROR(format, ...)  // Error log
VRB_LINE                // Print current file/function/line
```

**View logs:**
```bash
adb logcat -s VRB:*
```

### 2. Timing Instrumentation

Add timing measurements to identify bottlenecks:

```cpp
#include <chrono>

auto start = std::chrono::high_resolution_clock::now();
// ... code to measure ...
auto end = std::chrono::high_resolution_clock::now();
auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(end - start);
VRB_LOG("Operation took: %lld ms", duration.count());
```

---

## Key Files to Investigate

### 1. Hand Tracking Core Function
**File**: `app/src/openxr/cpp/OpenXRInputSource.cpp`

#### GetHandTrackingInfo() - Lines 527-615
This function retrieves hand joint positions each frame.

```cpp
bool OpenXRInputSource::GetHandTrackingInfo(XrTime predictedDisplayTime, XrSpace localSpace, const vrb::Matrix& head) {
    // Line 548 - This is the actual OpenXR call to get hand joints
    CHECK_XRCMD(OpenXRExtensions::sXrLocateHandJointsEXT(mHandTracker, &locateInfo, &jointLocations));
    
    // Lines 550-555 - METALENSE2 workaround already exists
    #if defined(SPACES)
        if (mDeviceType == device::LenovoA3 || mDeviceType == device::Metalense2)
            mHasHandJoints = true;
    #endif
}
```

**Add timing instrumentation here:**
```cpp
bool OpenXRInputSource::GetHandTrackingInfo(XrTime predictedDisplayTime, XrSpace localSpace, const vrb::Matrix& head) {
    static auto lastCall = std::chrono::high_resolution_clock::now();
    auto now = std::chrono::high_resolution_clock::now();
    auto callDelta = std::chrono::duration_cast<std::chrono::milliseconds>(now - lastCall);
    
    auto apiStart = std::chrono::high_resolution_clock::now();
    
    // ... existing code including xrLocateHandJointsEXT call ...
    
    auto apiEnd = std::chrono::high_resolution_clock::now();
    auto apiDuration = std::chrono::duration_cast<std::chrono::milliseconds>(apiEnd - apiStart);
    
    VRB_LOG("Hand tracking - Call interval: %lld ms, API call: %lld ms", 
            callDelta.count(), apiDuration.count());
    
    lastCall = now;
    // ... rest of function
}
```

#### Update() - Lines 747-1135
This is the main update function called every frame.

**Key line (802):**
```cpp
gotHandTrackingInfo = GetHandTrackingInfo(frameState.predictedDisplayTime, localSpace, head);
```

### 2. Frame Loop
**File**: `app/src/openxr/cpp/DeviceDelegateOpenXR.cpp`

Check `xrWaitFrame` and frame timing:
```cpp
// Look for these calls and measure their timing
xrWaitFrame(session, &frameWaitInfo, &frameState);
xrBeginFrame(session, &beginFrameInfo);
xrEndFrame(session, &endFrameInfo);
```

### 3. Main Render Loop
**File**: `app/src/main/cpp/BrowserWorld.cpp`

Check the main draw/update loop for any blocking operations.

---

## Debugging Steps

### Step 1: Measure Hand Tracking Call Frequency

Add logging to determine how often `GetHandTrackingInfo()` is called:

```cpp
// At the start of GetHandTrackingInfo()
static int callCount = 0;
static auto startTime = std::chrono::high_resolution_clock::now();
callCount++;
auto now = std::chrono::high_resolution_clock::now();
auto elapsed = std::chrono::duration_cast<std::chrono::seconds>(now - startTime);
if (elapsed.count() >= 1) {
    VRB_LOG("Hand tracking calls per second: %d", callCount);
    callCount = 0;
    startTime = now;
}
```

**Expected**: 60-90 calls per second (matching frame rate)
**Problem indicator**: < 30 calls per second

### Step 2: Measure xrLocateHandJointsEXT API Time

```cpp
auto start = std::chrono::high_resolution_clock::now();
CHECK_XRCMD(OpenXRExtensions::sXrLocateHandJointsEXT(mHandTracker, &locateInfo, &jointLocations));
auto end = std::chrono::high_resolution_clock::now();
auto duration = std::chrono::duration_cast<std::chrono::microseconds>(end - start);
VRB_LOG("xrLocateHandJointsEXT took: %lld us", duration.count());
```

**Expected**: < 1000 microseconds (1ms)
**Problem indicator**: > 5000 microseconds (5ms)

### Step 3: Measure Frame Time

Add to the main render loop:
```cpp
static auto lastFrame = std::chrono::high_resolution_clock::now();
auto now = std::chrono::high_resolution_clock::now();
auto frameDelta = std::chrono::duration_cast<std::chrono::milliseconds>(now - lastFrame);
if (frameDelta.count() > 20) {  // Log if frame takes > 20ms (< 50 FPS)
    VRB_WARN("Slow frame: %lld ms", frameDelta.count());
}
lastFrame = now;
```

### Step 4: Check for Blocking Operations

Search for potentially blocking code in the render path:
```bash
grep -r "sleep\|Sleep\|wait\|Wait\|mutex\|Mutex\|lock\|Lock" --include="*.cpp" app/src/
```

---

## Potential Root Causes & Solutions

### Cause 1: Frame Rate is Low
**Symptom**: Hand tracking calls per second < 30
**Solution**: The entire render loop is slow. Fix the frame rate first.

**Check**:
- Passthrough mode (may be consuming GPU resources)
- Excessive logging
- Heavy shader/rendering operations

### Cause 2: xrLocateHandJointsEXT API is Slow
**Symptom**: API call takes > 5ms
**Solution**: This is a runtime/SDK issue. Limited options:
- Report to Qualcomm Spaces SDK
- Check for SDK updates
- Try reducing hand tracking quality if configurable

### Cause 3: Hand Tracking Not Called Every Frame
**Symptom**: Call frequency much lower than frame rate
**Solution**: Check if there's conditional logic skipping hand tracking

**Look for**:
```cpp
// Any conditions that might skip hand tracking
if (isControllerUnavailable || mUsingHandInteractionProfile || mustAlwaysCheckHandTracking) {
    // hand tracking code
}
```

### Cause 4: predictedDisplayTime Issues
**Symptom**: API returns outdated joint positions
**Solution**: Verify correct timestamp is passed

```cpp
// Should use frameState.predictedDisplayTime
locateInfo.time = predictedDisplayTime;
VRB_LOG("predictedDisplayTime: %lld", predictedDisplayTime);
```

---

## Build and Test

After adding debug logging:

```bash
# Build
./gradlew assembleSpacesArm64GeckoGenericDebug

# Install
adb install -r app/build/outputs/apk/spacesArm64GeckoGeneric/debug/Wolvic-*-debug.apk

# View logs
adb logcat -c && adb logcat -s VRB:*
```

---

## Expected Output

After adding instrumentation, you should see logs like:
```
VRB: Hand tracking calls per second: 72
VRB: Hand tracking - Call interval: 14 ms, API call: 0 ms
VRB: xrLocateHandJointsEXT took: 245 us
```

**Good values**:
- Calls per second: 60-90
- Call interval: 11-17 ms
- API call time: < 1000 us

**Problem indicators**:
- Calls per second: < 30
- Call interval: > 33 ms
- API call time: > 5000 us

---

## Priority

1. **First**: Add timing instrumentation to identify the bottleneck
2. **Second**: Analyze logs to determine root cause
3. **Third**: Implement fix based on findings
4. **Fourth**: Remove debug logging and test final build

---

## Success Criteria

- [ ] Hand tracking updates at 60+ Hz
- [ ] No visible lag in hand movements
- [ ] Smooth, responsive pinch gestures
- [ ] Overall app runs at acceptable frame rate
