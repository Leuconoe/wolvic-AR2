# METALENSE2 Performance Issues - Critical Fix Required

## Context

The app now runs on METALENSE2, but there are **critical performance issues** that need immediate attention. The device is experiencing severe slowdowns and hand tracking update delays.

**Continue working autonomously until I explicitly tell you to stop.**

---

## Issue #1: Extremely Slow App Performance

### Problem
The application runs extremely slowly on METALENSE2. Overall responsiveness is severely degraded compared to Lenovo A3.

### Symptoms
- UI interactions are sluggish
- Frame rate appears very low
- General unresponsiveness throughout the app

### Root Cause Investigation

#### A. Frame Rate / Render Loop
Check if the render loop is throttled or blocked.

**Files to examine:**
- `app/src/openxr/cpp/DeviceDelegateOpenXR.cpp`
- `app/src/main/cpp/BrowserWorld.cpp`

**Key areas:**
```cpp
// Look for xrWaitFrame - may be blocking excessively
xrWaitFrame(session, &frameWaitInfo, &frameState);

// Check frame timing and predicted display time
frameState.predictedDisplayTime
frameState.predictedDisplayPeriod
```

#### B. OpenXR Session Configuration
Check session creation and configuration for performance settings.

**Search for:**
```bash
grep -r "xrCreateSession\|xrBeginSession\|XrSessionCreateInfo" --include="*.cpp" app/src/
```

#### C. Blend Mode / Composition
AR blend modes can be more expensive than VR opaque mode.

**Check:**
- `XR_ENVIRONMENT_BLEND_MODE_ALPHA_BLEND` vs `XR_ENVIRONMENT_BLEND_MODE_OPAQUE`
- Passthrough composition overhead

**Files:**
- `app/src/openxr/cpp/DeviceDelegateOpenXR.cpp`
- `app/src/openxr/cpp/OpenXRPassthroughStrategy.cpp`

#### D. CPU/GPU Throttling
Check if device is thermal throttling.

**Debug commands:**
```bash
# Check CPU frequencies
adb shell cat /sys/devices/system/cpu/cpu*/cpufreq/scaling_cur_freq

# Check thermal status
adb shell cat /sys/class/thermal/thermal_zone*/temp

# Check GPU frequency (if available)
adb shell cat /sys/class/kgsl/kgsl-3d0/gpuclk
```

#### E. Excessive Work Per Frame
Check for expensive operations in the render loop.

**Search for:**
```bash
# Find potential bottlenecks
grep -r "for.*loop\|while.*loop\|glDraw\|glBind" --include="*.cpp" app/src/main/cpp/
```

### Performance Profiling

1. **GPU Profiling:**
   ```bash
   adb shell setprop debug.egl.traceGpuCompletion 1
   adb logcat | grep -i "gpu\|frame\|render"
   ```

2. **Systrace:**
   ```bash
   python $ANDROID_HOME/platform-tools/systrace/systrace.py -o trace.html gfx view sched freq idle
   ```

3. **Frame Timing Logs:**
   Add logging to measure frame times:
   ```cpp
   auto start = std::chrono::high_resolution_clock::now();
   // ... frame work ...
   auto end = std::chrono::high_resolution_clock::now();
   auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(end - start);
   VRB_LOG("Frame time: %lld ms", duration.count());
   ```

### Possible Solutions

1. **Reduce render resolution for METALENSE2**
   - Look for resolution/scale settings in DeviceDelegateOpenXR.cpp

2. **Disable unnecessary features**
   - Passthrough (if still enabled)
   - Shader effects
   - Extra layers

3. **Optimize swapchain configuration**
   - Check swapchain format and sample count
   - File: `app/src/openxr/cpp/OpenXRSwapChain.cpp`

4. **Use simpler blend mode**
   ```cpp
   // Try using OPAQUE instead of ALPHA_BLEND
   XR_ENVIRONMENT_BLEND_MODE_OPAQUE
   ```

---

## Issue #2: Hand Tracking Update Interval Too Long

### Problem
Hand tracking is now functional, but the **update rate is too slow**, causing jerky/laggy hand movements.

### Expected Behavior
- Hand positions should update at 30-90 Hz (matching frame rate)
- Smooth, responsive hand tracking

### Actual Behavior
- Hands update infrequently
- Visible lag between hand movement and rendered position

### Root Cause Investigation

#### A. Hand Tracking Data Polling
Check how often hand tracking data is being requested.

**Files to examine:**
- `app/src/openxr/cpp/OpenXRInputSource.cpp`
- `app/src/openxr/cpp/OpenXRLayers.cpp` (if hand layer exists)

**Look for:**
```cpp
// Hand tracking locate calls
xrLocateHandJointsEXT()

// Check if this is being called every frame
```

#### B. OpenXR Hand Tracking Extension Configuration
Check the hand tracking extension setup.

**Search for:**
```bash
grep -r "XR_EXT_hand_tracking\|xrLocateHandJoints\|XrHandJointLocationsEXT" --include="*.cpp" --include="*.h" app/src/
```

#### C. Frame Synchronization
Hand tracking data should be requested with the correct predicted display time.

**Check:**
```cpp
// The time parameter passed to xrLocateHandJointsEXT
locateInfo.time = frameState.predictedDisplayTime; // Should use predicted time
```

#### D. Update Frequency Throttling
Look for any intentional throttling of hand tracking updates.

**Search for:**
```bash
grep -r "throttle\|interval\|update.*rate\|skip.*frame" --include="*.cpp" app/src/
```

#### E. Hand Tracking vs Controller Priority
Some implementations prioritize controllers over hands.

**Check:**
- Is hand tracking disabled when controllers are detected?
- Is there a fallback mechanism affecting update rate?

### Debug Logging

Add timing logs to hand tracking:
```cpp
// In hand tracking update function
static auto lastUpdate = std::chrono::high_resolution_clock::now();
auto now = std::chrono::high_resolution_clock::now();
auto delta = std::chrono::duration_cast<std::chrono::milliseconds>(now - lastUpdate);
VRB_LOG("Hand tracking update delta: %lld ms", delta.count());
lastUpdate = now;
```

### Possible Solutions

1. **Ensure hand tracking is called every frame**
   - Check that `xrLocateHandJointsEXT` is called in the main render loop

2. **Use correct timestamp**
   ```cpp
   // Use predicted display time, not current time
   locateInfo.time = frameState.predictedDisplayTime;
   ```

3. **Remove any frame skipping logic for hand tracking**

4. **Check for device-specific hand tracking rate limits**
   - METALENSE2 may have different rate limitations
   - May need to use different XrHandJointLocationsEXT configuration

5. **Verify hand tracking extension is properly initialized**
   ```cpp
   // Ensure these are set correctly
   XrHandTrackerCreateInfoEXT createInfo{};
   createInfo.hand = XR_HAND_LEFT; // or XR_HAND_RIGHT
   createInfo.handJointSet = XR_HAND_JOINT_SET_DEFAULT_EXT;
   ```

---

## Debugging Commands

```bash
# Monitor app performance
adb logcat -c && adb logcat | grep -E "(VRB|frame|hand|time|fps)"

# Check if app is running on correct thread
adb logcat | grep -i "thread\|looper"

# Monitor memory usage
adb shell dumpsys meminfo com.igalia.wolvic

# Check OpenXR runtime logs
adb logcat | grep -i "openxr\|spaces"
```

---

## Investigation Priority

1. **First**: Profile the app to identify the main bottleneck
2. **Second**: Check frame timing and render loop
3. **Third**: Verify hand tracking update frequency
4. **Fourth**: Apply optimizations and test

---

## Build and Test

After making changes:

```bash
# Build
./gradlew assembleSpacesArm64GeckoGenericDebug

# Install
adb install -r app/build/outputs/apk/spacesArm64GeckoGeneric/debug/Wolvic-*-debug.apk

# Monitor logs during testing
adb logcat -c && adb logcat > test_log.txt
```

---

## Success Criteria

- [ ] App runs at acceptable frame rate (60+ FPS for AR)
- [ ] UI is responsive to input
- [ ] Hand tracking updates smoothly (no visible lag)
- [ ] Hand movements feel responsive and accurate
- [ ] No regression on Lenovo A3

---

## Key Files Summary

| Issue | Primary Files to Check |
|-------|----------------------|
| Slow performance | `DeviceDelegateOpenXR.cpp`, `BrowserWorld.cpp`, `OpenXRSwapChain.cpp` |
| Hand tracking rate | `OpenXRInputSource.cpp`, `OpenXRLayers.cpp` |
| Both issues | OpenXR frame timing, `xrWaitFrame` implementation |

---

## Note

These two issues may be **related**. If the main render loop is slow, it will also affect how often hand tracking data is updated. **Fix the performance issue first**, then re-evaluate hand tracking update rate.
